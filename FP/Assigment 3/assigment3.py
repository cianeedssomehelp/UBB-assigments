"""
A menu-driven console application to help visualize the way searching and sorting algorithms work.
- Generate a list n of natural numbers. Generated numbers must be between 0 and 1000.
- Search for an item in the list using the algorithm you implemented.
- Sort the list using the first sorting algorithm.
- Sort the list using the second sorting algorithm.
- Exit the program.
"""
import random
import timeit
from texttable import Texttable
from sortandsearch import binarysearch
from sortandsearch import exchange_sort
from sortandsearch import strand_sort
from sortandsearch import exchange_sortwstep
from sortandsearch import strand_sortwstep


"""
A function that creates a menu like interface from where the user can choose an option 
(the choices are implemented in the main function).
"""

def printMenu():
    print("1. Generate a list of n random natural numbers. Generated numbers must be between 0 and 1000.")
    print("2. Search for an item in the list using the algorithm you implemented.")
    print("3. Sort the list using a basic algorithm.")
    print("4. Sort the list using an advanced algorithm.")
    print("5. Print the list.")
    print("6. Best case complexity.")
    print("7. Average case complexity.")
    print("8. Worst case complexity.")
    print("0. Exit the program.")

"""
A function that generates a random list with the numbers between 0 and 1000. 
Each time you want to start over with another list, the function clears the current list.
"""

def generaterandomlist(n, listofnumbers):
    listofnumbers.clear()
    for i in range(n):
        listofnumbers.append(random.randint(0, 1000))
    return listofnumbers

"""
Print function.
"""

def printrandomlist(listofnumbers):
    print ("Here's your list! :D : ", listofnumbers)


"""
Function that checks if the list is already sorted before the program uses the implemented 
sorting algorithms.
"""

def is_sorted(listofnumbers):
    for i in range(len(listofnumbers)-1):
        if listofnumbers[i] > listofnumbers[i+1]:
            return False
    return True

"""
The 3 following functions generate a list that is in descending order when we need to check
the worst case, randomly generated when we want to the average time of complexity and a sorted list
when we want to see how the best case complexity behaves.
"""

def generateworstcasedata(n):
    return list(range(n, 0, -1)) #the list is in descending order

def generateaveragecasedata(n):
    return [random.randint(0, 1000) for _ in range(n)]

def generatebestcasedata(n):
    return list(range(n)) #the list is already sorted


"""
This function measures the time it takes for a given algorithm to process a dataset. The function uses 
timeit.default_timer() to record the start time (start_time), then runs the provided algorithm on the data.
It records the end time (end_time) after the algorithm finishes running.
The time difference (result = end_time - start_time) is returned, giving the time in seconds that the algorithm took to complete.
data - list, algorithm - function to be timed
"""

def time_algorithm(algorithm, data):
    start_time = timeit.default_timer()
    algorithm(data)
    end_time = timeit.default_timer()
    result = end_time - start_time
    return result


"""
This function tests the performance of three algorithms 
(binary search, exchange sort, and strand sort) on datasets generated by a specific case generator function.
"""

def test_case(n, case_generator, case_name):
    print(f"Testing {case_name} case scenario...")
    for i in range(5):
        if i != 0:
            n *= 2
        data = case_generator(n)
        print(f"{case_name} case list of size {n}:")
        search_value = data[len(data) // 2]
        binary_search_time = time_algorithm(lambda lst: binarysearch(lst, 0, len(lst)-1, search_value), data.copy())
        print(f"Binary search time: {binary_search_time:.6f} seconds")
        print(f"Exchange Sort time: {time_algorithm(exchange_sort, data.copy()):.6f} seconds")
        print(f"Strand Sort time: {time_algorithm(strand_sort, data.copy()):.6f} seconds")
        print()


"""
This function creates a table showing the performance of binary search, 
exchange sort, and strand sort on randomly generated datasets of various sizes.
"""

def build_result_table(lenghts):
    table = Texttable()
    table.add_row(['Term', 'Binary Search', 'Exchange Sort', 'Strand Sort'])
    for length in lenghts:
        random_list = generaterandomlist(length, [])
        binary_search_time = time_algorithm(lambda x: binarysearch(x, 0, len(x)-1, x[len(x)//2]), random_list.copy()) #lambda is an anonymous function that takes a single argument x, in this case lambda is the binary search function and x is a list
        exchange_sort_time = time_algorithm(exchange_sort, random_list.copy())
        strand_sort_time = time_algorithm(strand_sort, random_list.copy())
        table.add_row([length, f"{binary_search_time:.6f}",f"{exchange_sort_time:.6f}", f"{strand_sort_time:.6f}"])
    print(table.draw())

"""
Main part of the program where all the choices for the menu items are implemented along with many
precautions that tell our program to stop at once if the input is not valid.
The first option helps you generate the random list and prints it so that you can see what you are working with.
The second option uses the binary search algorithm to search for a number of your choosing from the list. Don't forget the list must be sorted before choosing this option.
The third option lets you sort the list using exchange sort, a simple sorting algorithm that doesn't really have the best time and space complexity but it gets the job done.
The fourth option gives you the chance to sort the list using a more advanced sorting algorithm, strand sort.
The fifth option lets you print the list after you generate it or modify it.
The sixth option generates the best case complexity for binary search, strand sort and exchange sort.
The seventh option generates the average case complexity for binary search, strand sort and exchange sort.
The eight-th option generates the worst case complexity for binary search, strand sort and exchange sort.
For both of these algorithms there is included a step. You can choose to see progress of the sorting of the list by choosing a step (meaning the program will show you the progress each 1 sort or each 2 sorts).
"""


def main():
    listofnumbers = []
    while True:
        printMenu()
        option = input("Which option would you like to choose? :D : ")
        if option == "0":
            print("Thank you!")
            break
        elif option == "1":
            try:
                n = int(input("Choose the size of the random list: "))
                generaterandomlist(n, listofnumbers)
                printrandomlist(listofnumbers)
            except ValueError:
                print("Please enter a natural number.")
        elif option == "2":
            if not listofnumbers:
                print("This list is empty. Generate a list first.")
            elif is_sorted(listofnumbers):
                try:
                    item_search = int(input("Choose an item to search from the list: "))
                    item_found = binarysearch(listofnumbers, 0, len(listofnumbers)-1, item_search)
                    if item_found != -1:
                        print("Item found at index: ", item_found)
                    else:
                        print("Item not found.")
                except ValueError:
                    print("Please enter a valid number to search for.")
            else:
                print("Please choose one of the sorting algorithms to sort the list first!")
        elif option == "3":
            if not listofnumbers:
                print("This list is empty. Generate a list first.")
            else:
                try:
                    step = int(input("Enter a number of steps: "))
                    exchange_sortwstep(listofnumbers, step)
                    printrandomlist(listofnumbers)
                except ValueError:
                    print("Please enter a natural number.")
        elif option == "4":
            if not listofnumbers:
                print("This list is empty. Generate a list first.")
            else:
                try:
                    step = int(input("Enter a number of steps: "))
                    listofnumbers = strand_sortwstep(listofnumbers.copy(), step)
                    printrandomlist(listofnumbers)
                except ValueError:
                    print("Please enter a natural number.")
        elif option == "5":
            printrandomlist(listofnumbers)
        elif option == "6":
            try:
                n = int(input("Enter a natural number: "))
                if n < 1:
                    raise ValueError
                #test_case(n, generatebestcasedata, "Best")
                build_result_table([n * 2 ** i for i in range(5)])
            except ValueError:
                print("Please enter a natural number.")
        elif option == "7":
            try:
                n = int(input("Enter a natural number: "))
                if n < 1:
                    raise ValueError
                #test_case(n, generateaveragecasedata, "Average")
                build_result_table([n * 2 ** i for i in range(5)])
            except ValueError:
                print("Please enter a natural number.")
        elif option == "8":
            try:
                n = int(input("Enter a natural number: "))
                if n < 1:
                    raise ValueError
                #test_case(n, generateworstcasedata, "Worst")
                build_result_table([n * 2 ** i for i in range(5)])
            except ValueError:
                print("Please enter a natural number.")

        else:
            print("Invalid option. Please choose an option from 0-8 and try again.")

main()


